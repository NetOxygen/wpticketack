{"version":3,"sources":["app/Models/Screening.js"],"names":["e","a","define","dependencies","Screening","type","Array","Object","prototype","toString","call","_this","BaseModel","mapKeys","stop_at","start_at","buckets","length","rules","getInfos","r","ids","m","tasks","Date","u","s","infos","t","push","screening","chunks","callback","_","h","valueOf","c","infos_cache","ba","err","utc","L","_pf","empty","unusedTokens","async","_this2","overflow","charsLeftOver","eligible_types","isAlreadyGettingInfos","era","meridiem","rfc2822","_isValid","id","parsedDateParts","isNaN","_d","getTime","invalidEra","invalidMonth","invalidWeekday","weekdayMismatch","nullInput","invalidFormat","userInvalidated","_strict","bigHour","isFrozen"],"mappings":"CAAA,SAAAA,EAAAC,GAGAC,iB,gIAHA,C,iFAKI,SAASC,EAAAA,GAETC,OAAUC,aAAOC,OAFkD,mBAAAC,OAAAC,UAAAC,SAAAC,KAAAV,GAa1C,SAAAW,EAAAA,GAAcC,OAAAA,MAC/BZ,GAD+BY,oBAAdL,OAAAC,UAAAC,SAAAC,KAAAV,GAAA,SAKrBa,EAAAA,EAAKC,GAA4BA,OACjCH,OAAAH,UADiCM,eAAAA,KAAAA,EAAAA,GALZ,SASjBC,EAAAA,GAAA,GAAAR,OAAAO,oBAHoC,OAMpCE,IANoCT,OAAAS,oBAAAhB,GAAAiB,OAAA,IAVdhB,EAAA,IAAAA,KATqCiB,EA6BnEd,GAAUe,EAAAA,EAAAA,GACFf,OAXoC,OAahC,EAnBa,SAb0CgB,EAAApB,GA6B3BI,YAa9BiB,IAAWrB,EAAM,SACgBsB,EAAAtB,GAG/B,MAAA,iBAH+BmB,GAAAA,oBAG/BZ,OAAAC,UAAAC,SAAAC,KAAAV,GAJe,SAUvBI,EAAAA,GAOA,OAAMmB,aAjBiBC,MAAA,kBAAAjB,OAAAC,UAAAC,SAAAC,KAAAV,GAoBX,SAAAyB,EAAAzB,EAAAI,GADgD,IAAA,IAAAsB,EAAAC,GAAAC,EAFtB,EAAAA,EAAA5B,EAAAiB,SAEsBW,EAAAF,EAChDG,KAAA5B,EAAAD,EAAA4B,GAAAA,IAAA,OASRF,EA7BmB,SAgCSL,EAAAA,EACxBJ,GADwB,IAAA,IAAAW,KAExBE,EAWJC,EAAAA,EAAAA,KAAOC,EAAAA,GAAgBX,EAAhBW,IAjB6B,OAzCJT,EAAAA,EAAAU,cAAAjC,EAAAS,SAAAR,EAAAQ,UAAAyB,EAAAjC,EAAA,aAAAD,EAAAmC,QAAAlC,EAAAkC,SAAAnC,EA7B2B,SAAAoC,EAAApC,EA2FzDqC,EAAAA,EAAAA,GAA8B,OAAAC,GAAAtC,EAAAC,EAAAsC,EAAAb,GAAA,GAAAc,MAAA,SAAAC,EAAAzC,GAAA,OAAA,MA3F2BA,EAAA0C,MAAA1C,EAAA0C,IAAA,CAAAC,OA6B3B,EAabC,aAAA,GAwDJC,YACRC,GARyBC,UAAA,EAAAC,cAQzB,EArGnB9C,WAAAA,EAAAA,WA6EsB4B,KA7EtB5B,aA8E0B+C,KA9E1B/C,eAiF0BmC,EAjF1BnC,iBAmF2B4B,EAnF3B5B,KAqGmB,EAdPE,gBAAU8C,GAEVC,IAAA,KA7CmBC,SAAA,KA1CwCC,SAAA,EA2FnEjD,iBAAwB,IAAgB0C,EAAAA,IACN,SAC1BA,EAAAA,GAD0B,GADM,MAAA9C,EAAAsD,SAAA,CAIpC,IAAArD,EAAWwC,EAAAzC,GAAA4B,EAAC2B,EAAD7C,KAAQT,EAAAuD,gBAAA,SAAAxD,GACRuD,OAAMT,MADE9C,IAJiB0B,GAAA+B,MAAAzD,EAAA0D,GAAAC,YAAA1D,EAAA8C,SAAA,IAAA9C,EAAA0C,QAAA1C,EAAA2D,aAAA3D,EAAA4D,eAAA5D,EAAA6D,iBAAA7D,EAAA8D,kBAAA9D,EAAA+D,YAAA/D,EAAAgE,gBAAAhE,EAAAiE,mBAAAjE,EAAAmD,UAAAnD,EAAAmD,UAAAxB,GAOpC,GAAA5B,EAAAmE,UAAYZ,EAAO7B,GAAA,IAAAzB,EAAA+C,eAAA,IAAA/C,EAAA2C,aAAA3B,aAAA,IAAAhB,EAAAmE,SAAA,MAAA7D,OAAA8D,UAAA9D,OAAA8D,SAAArE,GACf,OAAO8C,EARyB9C,EAAAsD,SAAA5B,EAYxC,OAAOtB,EAAAA","file":"app.js","sourcesContent":["/**\n * Screening model\n */\ndefine(\n    ['module', 'lodash', 'moment', 'app/Models/Base', 'api', 'async'],\n    function dependencies(module, _, moment, BaseModel, TKTApi, async) {\n\n    Screening.type = 'screening';\n\n    /**\n     * Constructor\n     *\n     * @param {Object} screening like returned from the engine\n     */\n    function Screening(screening) {\n        BaseModel.call(this, screening);\n        screening = screening || {};\n\n        _.mapKeys(screening, (val, key) => {\n            this[key] = val;\n        });\n\n        this.start_at = moment(screening.start_at);\n        this.stop_at  = moment(screening.stop_at);\n        this.buckets  = this.buckets.map((b) => {\n            if ('not_before' in b.rules)\n                b.rules.not_before = moment(b.rules.not_before);\n            if ('not_after' in b.rules)\n                b.rules.not_after = moment(b.rules.not_after);\n\n            return b;\n        });\n    }\n\n    Screening.getInfos = (ids, callback) => {\n        if (Screening.isAlreadyGettingInfos)\n            return setTimeout(\n                () => Screening.getInfos(ids, callback),\n                500\n            );\n\n        // lock to prevent concurrent calls\n        Screening.isAlreadyGettingInfos = true;\n\n        const infos   = [];\n\n        // consider only not already loaded ids\n        ids = ids.filter(id => {\n            if (Screening.infos_cache.has(id)) {\n                infos.push(Screening.infos_cache.get(id));\n\n                return false;\n            }\n\n            return true;\n        });\n\n        if (ids.length === 0)\n            return callback(/*err*/null, infos);\n\n        // The chunk size could be more precise. For now, we\n        // know it works for 100 (for parc-aventure.ticketack.com)\n        // and not for 120.\n        const chunks = _.chunk(ids, 100);\n        const tasks  = _.map(chunks, (ids) => {\n            return (done) => {\n                TKTApi.getScreeningsInfo(ids, (err, status, rsp) => {\n                    if (err)\n                        return done(err);\n\n                    return done(/*err*/null, rsp);\n                });\n            };\n        });\n\n        async.parallel(tasks, (err, results) => {\n            if (err)\n                return err;\n\n            _.flatten(results).map(s => {\n                const screening = new Screening(s);\n                screening.eligible_types = s.eligible_types;\n\n                // put in cache\n                Screening.infos_cache.set(screening._id, screening);\n\n                infos.push(screening);\n            });\n\n            // release lock\n            Screening.isAlreadyGettingInfos = false;\n\n            return callback(/*err*/null, infos);\n        });\n    }\n\n    Screening.infos_cache = new (function() {\n        this.set = (id, screening) => {\n            this[id] = screening;\n        };\n        this.has = (id) => {\n            return id in this;\n        };\n        this.get = (id) => {\n            return this.has(id) ? this[id] : null;\n        };\n    });\n\n    return Screening;\n});\n"]}